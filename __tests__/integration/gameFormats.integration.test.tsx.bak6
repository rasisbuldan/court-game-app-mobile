/**
 * Game Formats Integration Tests
 *
 * Comprehensive tests for different game formats and scoring systems:
 * - Mexicano format with various court counts
 * - Americano format
 * - Mixed Mexicano format
 * - Points vs Games scoring modes
 * - First-to vs Target scoring
 * - Real-world tournament scenarios
 */

import { MexicanoAlgorithm } from '@courtster/shared';
import { supabase } from '../../config/supabase';
import { createTournamentData, playerFactory } from '../factories';

jest.mock('../../config/supabase');

describe('Game Formats Integration Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Mexicano Format - Points Scoring', () => {
    it('should handle 8 players, 2 courts, points to 32', () => {
      const players = Array.from({ length: 8 }, (_, i) =>
        playerFactory({ name: `Player ${i + 1}` })
      );
      const algorithm = new MexicanoAlgorithm(players, 2);

      // Generate 3 rounds
      for (let round = 1; round <= 3; round++) {
        const roundData = algorithm.generateRound(round);

        expect(roundData.roundNumber).toBe(round);
        expect(roundData.matches.length).toBe(2); // 8 players / 4 per match = 2 matches

        // Verify all players assigned
        const assignedPlayers = new Set<number>();
        roundData.matches.forEach(match => {
          match.team1.forEach(p => assignedPlayers.add(p));
          match.team2.forEach(p => assignedPlayers.add(p));
        });
        expect(assignedPlayers.size).toBe(8);

        // Simulate scoring
        roundData.matches.forEach((match, idx) => {
          match.team1Score = 32;
          match.team2Score = 20 + idx * 2; // Varying scores
          match.completed = true;
        });

        algorithm.updatePlayerStats(roundData, players);
      }

      // Verify final standings
      const sortedPlayers = [...players].sort((a, b) => b.points - a.points);
      expect(sortedPlayers[0].points).toBeGreaterThan(0);
      expect(sortedPlayers[0].points).toBeGreaterThanOrEqual(sortedPlayers[1].points);
    });

    it('should handle 12 players, 3 courts, points to 32', () => {
      const players = Array.from({ length: 12 }, (_, i) =>
        playerFactory({ name: `Player ${i + 1}` })
      );
      const algorithm = new MexicanoAlgorithm(players, 3);

      const round = algorithm.generateRound(1);

      expect(round.matches.length).toBe(3); // 12 players / 4 per match = 3 matches

      const assignedPlayers = new Set<number>();
      round.matches.forEach(match => {
        match.team1.forEach(p => assignedPlayers.add(p));
        match.team2.forEach(p => assignedPlayers.add(p));
      });
      expect(assignedPlayers.size).toBe(12);
    });

    it('should handle 16 players, 4 courts, points to 32', () => {
      const players = Array.from({ length: 16 }, (_, i) =>
        playerFactory({ name: `Player ${i + 1}` })
      );
      const algorithm = new MexicanoAlgorithm(players, 4);

      const round = algorithm.generateRound(1);

      expect(round.matches.length).toBe(4); // 16 players / 4 per match = 4 matches

      const assignedPlayers = new Set<number>();
      round.matches.forEach(match => {
        match.team1.forEach(p => assignedPlayers.add(p));
        match.team2.forEach(p => assignedPlayers.add(p));
      });
      expect(assignedPlayers.size).toBe(16);
    });
  });

  describe('Mexicano Format - Games Scoring (Tennis)', () => {
    it('should handle first-to-6-games scoring', () => {
      const players = Array.from({ length: 8 }, (_, i) =>
        playerFactory({ name: `Player ${i + 1}` })
      );
      const algorithm = new MexicanoAlgorithm(players, 2);
      const round = algorithm.generateRound(1);

      // Simulate tennis scoring (first to 6 games)
      round.matches.forEach((match, idx) => {
        match.team1Score = 6;
        match.team2Score = idx % 2 === 0 ? 4 : 3; // Varying scores
        match.completed = true;
      });

      algorithm.updatePlayerStats(round, players);

      // Verify games are counted
      expect(players.some(p => p.points > 0)).toBe(true);
    });

    it('should handle best-of-3-sets scoring', () => {
      const players = Array.from({ length: 8 }, (_, i) =>
        playerFactory({ name: `Player ${i + 1}` })
      );
      const algorithm = new MexicanoAlgorithm(players, 2);
      const round = algorithm.generateRound(1);

      // Simulate best of 3 sets (2 sets to win)
      round.matches.forEach(match => {
        match.team1Score = 2; // Won 2 sets
        match.team2Score = 0; // Lost 2 sets
        match.completed = true;
      });

      algorithm.updatePlayerStats(round, players);

      expect(players.some(p => p.points > 0)).toBe(true);
    });
  });

  describe('Player Count Variations', () => {
    const testCases = [
      { players: 4, courts: 1, matches: 1 },
      { players: 6, courts: 1, matches: 1 }, // 1 sitting out
      { players: 8, courts: 2, matches: 2 },
      { players: 10, courts: 2, matches: 2 }, // 2 sitting out
      { players: 12, courts: 3, matches: 3 },
      { players: 16, courts: 4, matches: 4 },
      { players: 20, courts: 5, matches: 5 },
    ];

    testCases.forEach(({ players: playerCount, courts, matches }) => {
      it(`should handle ${playerCount} players with ${courts} courts`, () => {
        const players = Array.from({ length: playerCount }, (_, i) =>
          playerFactory({ name: `Player ${i + 1}` })
        );
        const algorithm = new MexicanoAlgorithm(players, courts);
        const round = algorithm.generateRound(1);

        expect(round.matches.length).toBe(matches);

        // Verify players assigned to matches
        const assignedPlayers = new Set<number>();
        round.matches.forEach(match => {
          match.team1.forEach(p => assignedPlayers.add(p));
          match.team2.forEach(p => assignedPlayers.add(p));
        });

        // With sitting players, we expect courts * 4 players
        const expectedPlaying = courts * 4;
        expect(assignedPlayers.size).toBe(expectedPlaying);
      });
    });
  });

  describe('Sitting Players Management', () => {
    it('should rotate sitting players fairly over multiple rounds', () => {
      const playerCount = 10; // 2 will sit each round with 2 courts
      const courts = 2;
      const players = Array.from({ length: playerCount }, (_, i) =>
        playerFactory({ name: `Player ${i + 1}`, matchesPlayed: 0 })
      );
      const algorithm = new MexicanoAlgorithm(players, courts);

      const sittingCounts = new Map<number, number>();
      players.forEach(p => sittingCounts.set(p.id, 0));

      // Generate 5 rounds
      for (let round = 1; round <= 5; round++) {
        const roundData = algorithm.generateRound(round);

        const playingPlayers = new Set<number>();
        roundData.matches.forEach(match => {
          match.team1.forEach(p => playingPlayers.add(p));
          match.team2.forEach(p => playingPlayers.add(p));
        });

        // Track who sat out
        players.forEach(player => {
          if (!playingPlayers.has(player.id)) {
            sittingCounts.set(player.id, (sittingCounts.get(player.id) || 0) + 1);
          }
        });

        // Simulate match completion
        roundData.matches.forEach(match => {
          match.team1Score = 32;
          match.team2Score = 20;
          match.completed = true;
        });

        algorithm.updatePlayerStats(roundData, players);
      }

      // Verify sitting distribution is fair (within 1 round difference)
      const sitCounts = Array.from(sittingCounts.values());
      const maxSits = Math.max(...sitCounts);
      const minSits = Math.min(...sitCounts);
      expect(maxSits - minSits).toBeLessThanOrEqual(1);
    });
  });

  describe('Matchup Quality and Variety', () => {
    it('should avoid repeat partnerships in consecutive rounds', () => {
      const players = Array.from({ length: 8 }, (_, i) =>
        playerFactory({ name: `Player ${i + 1}` })
      );
      const algorithm = new MexicanoAlgorithm(players, 2);

      const partnerships = new Map<string, number>(); // "p1-p2" -> count

      // Generate 5 rounds
      for (let round = 1; round <= 5; round++) {
        const roundData = algorithm.generateRound(round);

        roundData.matches.forEach(match => {
          // Track team1 partnership
          const team1Key = [...match.team1].sort().join('-');
          partnerships.set(team1Key, (partnerships.get(team1Key) || 0) + 1);

          // Track team2 partnership
          const team2Key = [...match.team2].sort().join('-');
          partnerships.set(team2Key, (partnerships.get(team2Key) || 0) + 1);
        });

        // Simulate scoring
        roundData.matches.forEach(match => {
          match.team1Score = 32;
          match.team2Score = 20;
          match.completed = true;
        });

        algorithm.updatePlayerStats(roundData, players);
      }

      // Verify partnerships are varied (most should be 1 or 2 max)
      const partnershipCounts = Array.from(partnerships.values());
      const maxPartnership = Math.max(...partnershipCounts);
      expect(maxPartnership).toBeLessThanOrEqual(2); // No partnership more than twice in 5 rounds
    });

    it('should create competitive matchups based on standings', () => {
      const players = Array.from({ length: 8 }, (_, i) =>
        playerFactory({
          name: `Player ${i + 1}`,
          totalPoints: (7 - i) * 50 // Create standings spread
        })
      );
      const algorithm = new MexicanoAlgorithm(players, 2);

      const round = algorithm.generateRound(2); // Later round for better matching

      // Verify teams are balanced (top players not all on same team)
      round.matches.forEach(match => {
        const team1Points = match.team1.reduce((sum, player) => {
          return sum + (player?.totalPoints || 0);
        }, 0);

        const team2Points = match.team2.reduce((sum, player) => {
          return sum + (player?.totalPoints || 0);
        }, 0);

        // Teams should be within reasonable point difference
        const difference = Math.abs(team1Points - team2Points);
        const totalPoints = team1Points + team2Points;
        const diffPercentage = (difference / totalPoints) * 100;

        // Allow up to 30% difference for variety
        expect(diffPercentage).toBeLessThan(30);
      });
    });
  });

  describe('Score Validation', () => {
    it('should validate points scoring (0-100 range)', () => {
      const validScores = [0, 10, 32, 50, 100];
      const invalidScores = [-1, 101, 150];

      validScores.forEach(score => {
        expect(score).toBeGreaterThanOrEqual(0);
        expect(score).toBeLessThanOrEqual(100);
      });

      invalidScores.forEach(score => {
        const isInvalid = score < 0 || score > 100;
        expect(isInvalid).toBe(true);
      });
    });

    it('should validate games scoring (0-7 range for tennis)', () => {
      const validScores = [0, 3, 6, 7]; // 7 for tiebreak
      const invalidScores = [-1, 8, 10];

      validScores.forEach(score => {
        expect(score).toBeGreaterThanOrEqual(0);
        expect(score).toBeLessThanOrEqual(7);
      });

      invalidScores.forEach(score => {
        const isInvalid = score < 0 || score > 7;
        expect(isInvalid).toBe(true);
      });
    });

    it('should prevent tied final scores', () => {
      const tiedScores = [
        { team1: 32, team2: 32 },
        { team1: 6, team2: 6 },
        { team1: 0, team2: 0 },
      ];

      tiedScores.forEach(({ team1, team2 }) => {
        const isTied = team1 === team2;
        expect(isTied).toBe(true); // These should be rejected
      });
    });
  });

  describe('Session Status Workflow', () => {
    it('should progress through session statuses correctly', async () => {
      const statuses = ['setup', 'in_progress', 'completed'];

      for (let i = 0; i < statuses.length; i++) {
        const mockUpdate = jest.fn().mockReturnValue({
          eq: jest.fn().mockResolvedValue({
            data: { id: 'session-123', status: statuses[i] },
            error: null,
          }),
        });

        (supabase.from as jest.Mock).mockReturnValue({
          update: mockUpdate,
        });

        const result = await (supabase.from('game_sessions') as any)
          .update({ status: statuses[i] })
          .eq('id', 'session-123');

        expect(result.data.status).toBe(statuses[i]);
      }
    });
  });

  describe('Real-world Tournament Scenarios', () => {
    it('should handle complete 8-player, 3-round tournament', async () => {
      const tournamentData = createTournamentData(8, 3);

      expect(tournamentData.players.length).toBe(8);
      expect(tournamentData.rounds.length).toBe(3);
      expect(tournamentData.session.type).toBe('mexicano');

      // Verify all rounds have correct structure
      tournamentData.rounds.forEach((round, idx) => {
        expect(round.number).toBe(idx + 1);
        expect(round.matches.length).toBe(2); // 8 players / 4 = 2 matches
        expect(round.matches.every(m => m.team1Score !== undefined && m.team2Score !== undefined)).toBe(true);
      });

      // Verify final standings
      const sortedPlayers = [...tournamentData.players].sort((a, b) => b.totalPoints - a.totalPoints);
      expect(sortedPlayers[0].totalPoints).toBeGreaterThanOrEqual(0);
    });

    it('should handle late player arrival', () => {
      const players = Array.from({ length: 6 }, (_, i) =>
        playerFactory({
          name: `Player ${i + 1}`,
          status: i < 4 ? 'active' : 'late' // 2 players late
        })
      );

      const activePlayers = players.filter(p => p.status === 'active');
      const algorithm = new MexicanoAlgorithm(activePlayers, 1);

      const round = algorithm.generateRound(1);

      // Only 4 active players should be in matches
      const assignedPlayers = new Set<number>();
      round.matches.forEach(match => {
        match.team1.forEach(p => assignedPlayers.add(p));
        match.team2.forEach(p => assignedPlayers.add(p));
      });

      expect(assignedPlayers.size).toBe(4);
    });

    it('should handle player departure mid-tournament', () => {
      const players = Array.from({ length: 8 }, (_, i) =>
        playerFactory({
          name: `Player ${i + 1}`,
          status: 'active'
        })
      );

      // Simulate round 1
      const algorithm = new MexicanoAlgorithm(players, 2);
      const round1 = algorithm.generateRound(1);
      expect(round1.matches.length).toBe(2);

      // Player departs after round 1
      players[7].status = 'departed';
      const activePlayers = players.filter(p => p.status === 'active');

      // Round 2 with 7 players (1 will sit)
      const algorithm2 = new MexicanoAlgorithm(activePlayers, 2);
      const round2 = algorithm2.generateRound(2);

      // Should still have 2 courts but with 1 sitting
      expect(round2.matches.length).toBeLessThanOrEqual(2);
    });
  });
});
